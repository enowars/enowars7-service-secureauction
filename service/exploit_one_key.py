import requests
import logging
import random
import string
from bs4 import BeautifulSoup
import gmpy2
import time
from sympy import *


logger = logging.getLogger(__name__)
# Create a requests session
session = requests.Session()

def signup(user_name, password, user_type='REGULAR'):
    logger.info(f"Starting signup process for user: {user_name}")
    signup_data = {
        "user_name": user_name,
        "password": password,
        "user_type": user_type,
        "action": "signup"
    }
    response = session.post("http://localhost:8181/", data=signup_data)
    status_code = response.status_code
    logger.info(f"Received status code {status_code} for signup process")

    if status_code in [200, 302]:
        # Check if a redirection occurred
        if 'Location' in response.headers:
            new_url = response.headers['Location']
            response = requests.get(new_url)  # Fetch the redirected page
            status_code = response.status_code
            logger.info(f"Received status code {status_code} for redirected page")


        if user_type == 'PREMIUM':
            # Parse the private key and user_id from the response
            soup = BeautifulSoup(response.text, 'html.parser')
            private_key_elements = soup.find_all('p', class_='key-chunk')
            private_key = ''.join(element.text for element in private_key_elements)

            user_id_element = soup.find('input', id='userId')
            user_id = user_id_element['value'] if user_id_element else None 

            logger.info(f"Parsed private key: {private_key} and user_id: {user_id}")
            return private_key, user_id
        elif user_type == 'REGULAR':   
            return 
        else: 
            logger.error(f"Invalid user type: {user_type}")
            raise Exception(f"Invalid user type: {user_type}")
    else:
        logger.error(f"Failed to sign up the user. {status_code}")
        raise Exception(f"Failed to sign up the user. {status_code}")


def bisect(f, low, up, rounding = 0):
    flow = f(low)
    fup = f(up)
    if flow == 0: return low
    if fup == 0: return up
    if flow * fup > 0: raise ValueError('bad interval')
    if flow < 0:
        return _bisect(f, low,up,rounding)
    else:
        return _bisect(lambda x: -f(x), low, up,rounding)

def _bisect(f, low, up, rounding):
    if up <= low + 1:
        if rounding == 1:
            return up
        elif rounding == -1:
            return low
        else:
            raise ValueError('no root or bad function')
    mid = (low + up) // 2
    midval = f(mid)
    if midval == 0: return mid
    if midval < 0: return _bisect(f, mid, up, rounding)
    if midval > 0: return _bisect(f, low, mid, rounding)

def calculate_d(p, q, e, rounding = 0):
    # Calculate the totient φ(n) = (p - 1)(q - 1)
    phi_n = (p - 1) * (q - 1)

    # Calculate d, the modular inverse of e under φ(n)
    d = mod_inverse(e, phi_n)

    print(f"Calculated rounding: {rounding}")
    print(f"Calculated d: {d}")
    return d

def exploit(e, n):
    # given n and e
    n = n
    e = e

    for rounding in [0, 1, -1]: # iterate over desired rounding values
        for offset in range(10,2048,2):
            try:  
                p = bisect(lambda x: x * (x * (x+10) + offset) - n, 0, 1<<512, rounding = rounding)
                #print(f"Calculated p: {p}")
                increased_p = p + 10
                number = p * increased_p
                q = nextprime(number)
                #print(f"Calculated q: {q}")
                d = calculate_d(p, q, e, rounding)
                if d is not None:
                        return d  # d was found and will be returned
            except ValueError:
                pass
    
def decrypt(c, d, n):
    # Perform the decryption
    m = gmpy2.powmod(c, d, n)
    # Convert the result to a hexadecimal string
    m_hex = gmpy2.digits(m, 16)
    # Convert the hexadecimal string into a binary string (which is our original message)
    m_string = bytes.fromhex(m_hex).decode('utf-8')
    print(f"Decrypted message: {m_string}")
    

if __name__ == "__main__":
    user_name = ''.join(random.choices(string.ascii_lowercase, k=10))
    password = ''.join(random.choices(string.ascii_lowercase, k=10))
    print(f"Generated user_name: {user_name}")
    print(f"Generated password: {password}")

    private_key, user_id = signup(user_name, password, 'PREMIUM')  # type: ignore
    print(f"Signed up user: {user_name} with private key: {private_key} and user_id: {user_id}")  # type: ignore
    
    t0 = time.time()
    e = 65537
    n = 100265616783307999353667143761374312224554013511081913218362898289086719479411824400759122207157863510185101730842538464256934070988397324001542263564041060752161898603179072708929266263305055820695981330664406498759304369827451494661708268114863375051696735803015897390890247755785590197752089153543077827928374888844633595715059515923008432918861082713435653306280686337326234108406779661433777115436133781408681797564553390043438776174022315902650847586585683   
    enc_bid = 67949489078029657628296586998792479937748161822099174410366526988657888206188586635613077535191344490065371809135692823743621270741956276508514005177365026920839950860537577253868427119927068187780544532254698007141749155458677361850405919829277710735723025328501461921653883300903330163740170242196006763662693237324930786800021118372905981768996782003702923232194575388242514950769578697268821519092870936725756834010956696400050472828493836474957621207051518
    d = exploit(e, n)
    decrypt(enc_bid, d, n)
    print('\n')

    print('time: %.2f s' % (time.time() - t0))