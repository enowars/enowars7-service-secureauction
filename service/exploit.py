import time
from sympy import *

def bisect(f, low, up, rounding = 0):
    flow = f(low)
    fup = f(up)
    if flow == 0: return low
    if fup == 0: return up
    if flow * fup > 0: raise ValueError('bad interval')
    if flow < 0:
        return _bisect(f, low,up,rounding)
    else:
        return _bisect(lambda x: -f(x), low, up,rounding)

def _bisect(f, low, up, rounding):
    if up <= low + 1:
        if rounding == 1:
            return up
        elif rounding == -1:
            return low
        else:
            raise ValueError('no root or bad function')
    mid = (low + up) // 2
    midval = f(mid)
    if midval == 0: return mid
    if midval < 0: return _bisect(f, mid, up, rounding)
    if midval > 0: return _bisect(f, low, mid, rounding)

def calculate_d(p, q, e):
    # Calculate the totient φ(n) = (p - 1)(q - 1)
    phi_n = (p - 1) * (q - 1)

    # Calculate d, the modular inverse of e under φ(n)
    d = mod_inverse(e, phi_n)

    print(f"Calculated d: {d}")

def main():
    # given n and e
    n = 1435689422691838807556381016551693773067981144352000111864559714424473128736935691311077155297425742436616142704192773454619127670920843337870025009592469308837144786302391398091088380508077183811645064122906875445539738039253377
    e = 5

    t0 = time.time()
    for offset in range(10,2048,2):
        try:  
            p = bisect(lambda x: x * (x * (x+10) + offset) - n, 0, 1<<512, rounding = 0)
            print(p)
            increased_p = p + 10
            number = p * increased_p
            q = nextprime(number)
            print(f"Calculated q: {q}")
            calculate_d(p, q, e)
            break
        except ValueError:
            pass
    print('time: %.2f s' % (time.time() - t0))

if __name__ == "__main__":
    main()
